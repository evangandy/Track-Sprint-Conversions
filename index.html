import React, { useState, useEffect } from 'react';
import { 
  LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer
} from 'recharts';

const SprintTimeConverter = () => {
  // Conversion table from the image
  const conversionTable = {
    distances: [36.576, 50, 55, 60, 100, 200],
    ratios: [
      [1, 0.7680406888, 0.6879633611, 0.6400911027, 0.4156435732, 0.1951099662],
      [1.302022728, 1, 0.8957511648, 0.8334198251, 0.5411817046, 0.2540211598],
      [1.453580765, 1.1164181518, 1, 0.9304168742, 0.6041668015, 0.2836335064],
      [1.562328762, 1.1999441652, 1.0748165, 1, 0.6493506494, 0.3048232375],
      [2.405986293, 1.8479101448, 1.6552174571, 1.54, 1, 0.4694278434],
      [5.130391123, 3.9400926701, 3.5298386571, 3.2839024271, 2.1324041748, 1]
    ]
  };

  // State
  const [knownDistance, setKnownDistance] = useState(36.576);
  const [knownTime, setKnownTime] = useState(4.5);
  const [targetDistance, setTargetDistance] = useState(100);
  const [predictedTime, setPredictedTime] = useState(null);
  const [modelTimes, setModelTimes] = useState([]);
  // No tabs state needed

  // Calculate predicted time
  useEffect(() => {
    if (knownDistance && knownTime && targetDistance) {
      // Find indices
      const knownIndex = conversionTable.distances.indexOf(parseFloat(knownDistance));
      const targetIndex = conversionTable.distances.indexOf(parseFloat(targetDistance));
      
      if (knownIndex !== -1 && targetIndex !== -1) {
        // Get ratio from table
        const ratio = conversionTable.ratios[targetIndex][knownIndex];
        const calculatedTime = (parseFloat(knownTime) * ratio).toFixed(2);
        setPredictedTime(calculatedTime);
        
        // Calculate all times for the chart
        const times = conversionTable.distances.map((dist, idx) => {
          const r = conversionTable.ratios[idx][knownIndex];
          return {
            distance: dist,
            time: parseFloat((parseFloat(knownTime) * r).toFixed(2))
          };
        });
        setModelTimes(times);
      }
    }
  }, [knownDistance, knownTime, targetDistance]);

  // Format numbers with 2 decimal places
  const formatNumber = (num) => {
    return parseFloat(num).toFixed(2);
  };

  // No heatmap code needed anymore

  // Generate comparison table data
  const generateTimesTable = () => {
    if (!knownDistance || !knownTime) return [];
    
    return conversionTable.distances.map(dist => {
      const tableIdx = conversionTable.distances.indexOf(parseFloat(knownDistance));
      const targetIdx = conversionTable.distances.indexOf(parseFloat(dist));
      
      let tableTime = null;
      if (tableIdx !== -1 && targetIdx !== -1) {
        const ratio = conversionTable.ratios[targetIdx][tableIdx];
        tableTime = knownTime * ratio;
      }
      
      return {
        distance: dist,
        tableTime: tableTime ? parseFloat(tableTime.toFixed(2)) : null
      };
    });
  };

  return (
    <div className="max-w-4xl mx-auto p-4 bg-gray-50 rounded-lg shadow">
      <h1 className="text-2xl font-bold text-center mb-6">Sprint Performance Analyzer</h1>
      
      {/* No tabs needed since we only have the converter now */}
      
      <div>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
          <div className="p-4 bg-white rounded shadow">
            <label className="block mb-2 font-semibold">Known Distance (meters)</label>
            <select 
              className="w-full p-2 border rounded"
              value={knownDistance}
              onChange={(e) => setKnownDistance(parseFloat(e.target.value))}
            >
              {conversionTable.distances.map(dist => (
                <option key={dist} value={dist}>{dist}m {dist === 36.576 ? '(40yd)' : ''}</option>
              ))}
            </select>
          </div>
          
          <div className="p-4 bg-white rounded shadow">
            <label className="block mb-2 font-semibold">Known Time (seconds)</label>
            <input 
              type="number" 
              step="0.01"
              className="w-full p-2 border rounded"
              value={knownTime}
              onChange={(e) => setKnownTime(e.target.value)}
            />
          </div>
          
          <div className="p-4 bg-white rounded shadow">
            <label className="block mb-2 font-semibold">Target Distance (meters)</label>
            <select 
              className="w-full p-2 border rounded"
              value={targetDistance}
              onChange={(e) => setTargetDistance(parseFloat(e.target.value))}
            >
              {conversionTable.distances.map(dist => (
                <option key={dist} value={dist}>{dist}m {dist === 36.576 ? '(40yd)' : ''}</option>
              ))}
            </select>
          </div>
        </div>
        
        {predictedTime && (
          <div className="mb-6 p-6 bg-white rounded shadow text-center">
            <h2 className="text-xl font-bold mb-2">Predicted Time</h2>
            <p className="text-3xl font-bold text-blue-600">{predictedTime} seconds</p>
            <p className="text-sm text-gray-500">
              Based on {knownTime}s at {knownDistance}m
            </p>
          </div>
        )}
        
        {modelTimes.length > 0 && (
          <div className="mb-6 p-4 bg-white rounded shadow">
            <h2 className="text-lg font-bold mb-4">Performance Curve</h2>
            <div className="h-64">
              <ResponsiveContainer width="100%" height="100%">
                <LineChart data={modelTimes} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis 
                    dataKey="distance" 
                    label={{ value: 'Distance (meters)', position: 'insideBottom', offset: -5 }}
                  />
                  <YAxis 
                    label={{ value: 'Time (seconds)', angle: -90, position: 'insideLeft' }}
                  />
                  <Tooltip formatter={(value) => [`${value}s`, 'Time']} />
                  <Line 
                    type="monotone" 
                    dataKey="time" 
                    stroke="#8884d8" 
                    activeDot={{ r: 8 }}
                    name="Predicted Time"
                  />
                </LineChart>
              </ResponsiveContainer>
            </div>
          </div>
        )}
        
        <div className="mb-6 p-4 bg-white rounded shadow">
          <h2 className="text-lg font-bold mb-4">Predicted Times for All Distances</h2>
          <div className="overflow-x-auto">
            <table className="min-w-full bg-white">
              <thead>
                <tr>
                  <th className="p-3 border">Distance (m)</th>
                  <th className="p-3 border">Predicted Time (s)</th>
                </tr>
              </thead>
              <tbody>
                {generateTimesTable().map((item, i) => (
                  <tr key={i} className={item.distance === parseFloat(targetDistance) ? "bg-blue-100" : ""}>
                    <td className="p-3 border">{item.distance}</td>
                    <td className="p-3 border">{item.tableTime}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SprintTimeConverter;
